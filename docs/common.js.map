{"version":3,"file":"common.js","mappings":";;;;;;;;;;;;;;;AAAqG;;AAE7D;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAY;AAC1C;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uCAAuC,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,iDAAa;AACjM,0CAA0C,+DAAwB,GAAG,6EAA6E,gDAAgD,aAAa,0BAA0B,aAAa,kEAA2B,GAAG;AACpR;AACA,MAAM,MAAM,qDAAU,GAAG;AACzB,MAAM,MAAM,iDAAM,GAAG;AACrB;AACA;AACA,eAAe,MAAM,gDAAK,EAAE;AAC5B,kBAAkB,MAAM,gDAAK,EAAE;AAC/B,eAAe,MAAM,gDAAK,EAAE;AAC5B,qBAAqB,MAAM,iDAAM,EAAE;AACnC;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA,aAAa;AACb,KAAK,iBAAiB,UAAU,MAAM,qDAAiB,EAAE,IAAI,MAAM,iDAAa,EAAE,IAAI,IAAI;AAC1F,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS,GAAG,IAAI;;AAEhB;AACA;AACA,2DAA2D;AAC3D,oCAAoC,8DAAuB,GAAG,sBAAsB;AACpF,oCAAoC,8DAAuB,GAAG;AAC9D,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,iBAAiB;AACtB,eAAe,mDAAmD,gEAAyB,mBAAmB,uEAAuE,IAAI;;AAEzI;;;;;;;;;;;;;;;;;;;;;;AClFZ;AACM;AACI;AACc;AACa;AACb;AACrD,4BAA4B,6CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAuB;AAC7C;AACA;AACA,2BAA2B,6DAAkB;AAC7C;AACA;AACA;AACA,+BAA+B,qEAAmB;AAClD;AACA;AACA,4CAA4C,qEAAmB;AAC/D;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtG2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["./node_modules/angular-morris-js/__ivy_ngcc__/esm2015/angular-morris-js.js","./node_modules/rxjs/_esm2015/internal/ReplaySubject.js","./node_modules/rxjs/_esm2015/internal/operators/pairwise.js"],"sourcesContent":["import { Directive, Input, ElementRef, NgZone, Output, EventEmitter, NgModule } from '@angular/core';\n\nimport * as ɵngcc0 from '@angular/core';\nclass MorrisChartDirective {\n    constructor(elementRef, ngZone) {\n        this.elementRef = elementRef;\n        this.ngZone = ngZone;\n        this.window = window;\n        this.type = 'Line';\n        this.clickChart = new EventEmitter();\n    }\n    ngOnInit() {\n        this._options = Object.assign({}, this.options);\n        this._options.element = this.elementRef.nativeElement;\n        this._options.data = this.data;\n    }\n    ngAfterViewInit() {\n        if (!this.window.Morris) {\n            throw new Error('Please include node_modules/morris.js/morris.js');\n        }\n        else {\n            this.ngZone.runOutsideAngular(() => {\n                this.chartInstance = new this.window.Morris[this.type](this._options);\n                this.chartInstance.on('click', (i, row) => {\n                    this.clickChart.emit({ event, i, row });\n                });\n            });\n        }\n    }\n    ngOnChanges(changes) {\n        if ((changes[\"data\"] && !changes[\"data\"].firstChange) || (changes[\"options\"] && !changes[\"options\"].firstChange)) {\n            Object.assign(this.chartInstance.options, this.options);\n            this.chartInstance.setData(this.data);\n        }\n    }\n    ngOnDestroy() {\n        if (this.chartInstance.el.empty instanceof Function) {\n            this.chartInstance.el.empty();\n        }\n    }\n}\nMorrisChartDirective.ɵfac = function MorrisChartDirective_Factory(t) { return new (t || MorrisChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nMorrisChartDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MorrisChartDirective, selectors: [[\"\", \"mk-morris-js\", \"\"]], inputs: { type: \"type\", options: \"options\", data: \"data\" }, outputs: { clickChart: \"clickChart\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\nMorrisChartDirective.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: NgZone, },\n];\nMorrisChartDirective.propDecorators = {\n    \"type\": [{ type: Input },],\n    \"options\": [{ type: Input },],\n    \"data\": [{ type: Input },],\n    \"clickChart\": [{ type: Output },],\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MorrisChartDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[mk-morris-js]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { type: [{\n            type: Input\n        }], clickChart: [{\n            type: Output\n        }], options: [{\n            type: Input\n        }], data: [{\n            type: Input\n        }] }); })();\n\nclass MorrisJsModule {\n}\nMorrisJsModule.ɵfac = function MorrisJsModule_Factory(t) { return new (t || MorrisJsModule)(); };\nMorrisJsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MorrisJsModule });\nMorrisJsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MorrisJsModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [MorrisChartDirective],\n                exports: [MorrisChartDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MorrisJsModule, { declarations: [MorrisChartDirective], exports: [MorrisChartDirective] }); })();\n\nexport { MorrisChartDirective, MorrisJsModule };\n\n","import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        const _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function pairwise() {\n    return (source) => source.lift(new PairwiseOperator());\n}\nclass PairwiseOperator {\n    call(subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    }\n}\nclass PairwiseSubscriber extends Subscriber {\n    constructor(destination) {\n        super(destination);\n        this.hasPrev = false;\n    }\n    _next(value) {\n        let pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    }\n}\n"],"names":[],"sourceRoot":"webpack:///"}